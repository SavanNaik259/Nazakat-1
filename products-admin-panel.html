<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nazakat Admin Panel - Product Management</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
        }

        .admin-container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }

        .admin-header {
            background: white;
            color: #1e293b;
            padding: 24px 30px;
            text-align: center;
            border-bottom: 1px solid #e2e8f0;
        }

        .admin-header h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #2563eb;
        }

        .admin-header p {
            color: #64748b;
            font-size: 14px;
            margin: 0;
        }

        .form-container {
            padding: 40px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
            font-size: 1.1em;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.2s ease;
            background: white;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 120px;
        }

        .file-input-container {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: block;
            padding: 15px;
            border: 2px dashed #2563eb;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #f8fafc;
        }

        .file-input-label:hover {
            background: #eff6ff;
            border-color: #1d4ed8;
        }

        .file-input-label i {
            font-size: 2em;
            color: #2563eb;
            margin-bottom: 10px;
            display: block;
        }

        .submit-btn {
            background-color: #2563eb;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 500;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            margin-top: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .submit-btn:hover {
            background-color: #1d4ed8;
        }

        .submit-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading i {
            animation: spin 1s linear infinite;
            font-size: 2em;
            color: #2563eb;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .success-message,
        .error-message {
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            display: none;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .image-preview {
            margin-top: 10px;
            display: none;
        }

        .image-preview img {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
        }

        /* Multi-image upload styles */
        .multi-image-container {
            border: 2px dashed #2563eb;
            border-radius: 6px;
            padding: 20px;
            margin: 15px 0;
            background: #f8fafc;
            text-align: center;
        }

        .multi-image-container.dragover {
            background: #eff6ff;
            border-color: #1d4ed8;
        }

        .image-grid {
            display: flex;
            flex-direction: row;
            gap: 15px;
            margin-top: 20px;
            overflow-x: auto;
            padding: 10px;
            align-items: flex-start;
            flex-wrap: nowrap;
        }

        .image-item {
            position: relative;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            background: white;
            flex: 0 0 200px;
            min-width: 200px;
            width: 200px;
        }

        .image-item img {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }

        .image-item .image-controls {
            position: absolute;
            top: 5px;
            right: 5px;
            display: flex;
            gap: 5px;
        }

        .control-btn {
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: 3px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: rgba(0,0,0,0.9);
        }

        .control-btn.main {
            background: #c9a876;
        }

        .control-btn.main:hover {
            background: #b8956a;
        }

        .image-item .image-info {
            padding: 8px;
            font-size: 11px;
            background: #f8f9fa;
            text-align: center;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .main-image-badge {
            position: absolute;
            bottom: 5px;
            left: 5px;
            background: #c9a876;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
        }

        .upload-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(0,0,0,0.1);
        }

        .upload-progress-bar {
            height: 100%;
            background: #2563eb;
            transition: width 0.3s ease;
        }

        /* Image ordering and positioning styles */
        .position-label {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            z-index: 10;
            min-width: 20px;
            text-align: center;
        }

        .position-label.main {
            background: #c9a876;
            color: white;
            font-weight: bold;
        }

        .image-position-controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(0, 0, 0, 0.85);
            padding: 4px 8px;
            border-radius: 15px;
            z-index: 10;
        }

        .position-btn {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: none;
            border-radius: 50%;
            padding: 2px 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .position-btn:hover:not(:disabled) {
            background: white;
            transform: scale(1.1);
        }

        .position-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .position-select {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            padding: 2px 4px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            min-width: 25px;
            text-align: center;
            height: 18px;
        }

        .position-select:hover {
            background: white;
        }

        .position-select:focus {
            outline: none;
            background: white;
            box-shadow: 0 0 3px rgba(37, 99, 235, 0.5);
        }

        /* Enhance image item for ordering */
        .image-item {
            cursor: move;
            position: relative;
        }

        .image-item.dragging {
            opacity: 0.6;
            transform: scale(0.95);
            border: 2px dashed #2563eb;
        }

        .image-item.drag-over {
            border: 3px dashed #2563eb;
            background: rgba(37, 99, 235, 0.1);
            transform: scale(1.02);
        }

        /* Highlight main image */
        .image-item.main-image {
            border: 3px solid #c9a876;
            box-shadow: 0 4px 12px rgba(201, 168, 118, 0.3);
        }

        /* Image placeholder for maintaining order */
        .image-placeholder {
            flex: 0 0 200px;
            min-width: 200px;
            width: 200px;
            height: 240px;
            background: #f0f0f0;
            border: 2px dashed #ddd;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 12px;
        }

        /* Image Compression Settings Styles */
        .compression-settings {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            position: relative;
        }

        .compression-settings h3 {
            color: #374151;
            font-size: 16px;
            font-weight: 600;
            margin: 0 0 25px 0;
            display: flex;
            align-items: center;
            gap: 8px;
            padding-right: 180px;
        }

        .compression-toggle {
            position: absolute;
            top: 22px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            color: #374151;
        }

        .compression-toggle input {
            width: auto;
            margin-right: 8px;
        }

        .compression-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        /* Responsive design for compression options */
        @media (max-width: 768px) {
            .compression-options {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        @media (max-width: 480px) {
            .compression-settings {
                padding: 15px;
            }
            
            .compression-settings h3 {
                padding-right: 0;
                margin-bottom: 15px;
            }
            
            .compression-toggle {
                position: static;
                margin-bottom: 15px;
                justify-content: flex-start;
            }
            
            .compression-options {
                gap: 12px;
            }
            
            .compression-option {
                padding: 8px;
            }
        }

        /* Better slider styling */
        .compression-option input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #e5e7eb;
            outline: none;
            margin: 10px 0;
        }

        .compression-option input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(37, 99, 235, 0.3);
        }

        .compression-option input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(37, 99, 235, 0.3);
        }

        .compression-option input[type="range"]::-webkit-slider-track {
            -webkit-appearance: none;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, #ef4444 0%, #f59e0b 50%, #10b981 100%);
        }

        .compression-option input[type="range"]::-moz-range-track {
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, #ef4444 0%, #f59e0b 50%, #10b981 100%);
            border: none;
        }

        .compression-option {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
            background: #f9fafb;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
        }

        .compression-option label {
            font-size: 14px;
            font-weight: 500;
            color: #4b5563;
            margin: 0;
            line-height: 1.4;
        }


        .compression-option select,
        .compression-option input[type="number"] {
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        .compression-option small {
            font-size: 12px;
            color: #6b7280;
            line-height: 1.3;
            margin-top: 2px;
        }

        .compression-preview {
            margin-top: 15px;
            padding: 10px;
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 12px;
            color: #6b7280;
        }

        .compression-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
        }

        .size-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }

        .size-original {
            background: #fef3c7;
            color: #92400e;
        }

        .size-compressed {
            background: #d1fae5;
            color: #065f46;
        }

        .compression-progress {
            margin-top: 10px;
            height: 4px;
            background: #f3f4f6;
            border-radius: 2px;
            overflow: hidden;
            display: none;
        }

        .compression-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            transition: width 0.3s ease;
            width: 0%;
        }

        .compression-disabled {
            opacity: 0.6;
            pointer-events: none;
        }

        .compression-info {
            background: #eff6ff;
            color: #1e40af;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            margin-top: 10px;
            border-left: 3px solid #3b82f6;
        }

        /* Image item compression badge */
        .compression-badge {
            position: absolute;
            bottom: 45px;
            right: 5px;
            background: rgba(34, 197, 94, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            display: none;
        }

        .image-item.compressed .compression-badge {
            display: block;
        }
    </style>
</head>
<body>
    <div class="admin-container">
        <div class="admin-header">
            <h1>Nazakat Admin Panel</h1>
            <p>Product Management System</p>
        </div>

        <div class="form-container">
            <form id="productForm">
                <div class="form-group">
                    <label for="productName">Product Name</label>
                    <input type="text" id="productName" name="productName" required>
                </div>

                <div class="form-group">
                    <label for="productPrice">Price (₹)</label>
                    <input type="number" id="productPrice" name="productPrice" min="1" required>
                </div>

                <div class="form-group">
                    <label for="productStock">Stock Quantity</label>
                    <input type="number" id="productStock" name="productStock" min="0" required>
                </div>

                <div class="form-group">
                    <label for="productCategory">Category</label>
                    <select id="productCategory" name="productCategory" required>
                        <option value="">Select Category</option>
                        <option value="featured-collection">Featured Collection</option>
                        <option value="saree-collection">Saree Collection</option>
                        <option value="new-arrivals">New Arrivals</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="productDescription">Description</label>
                    <textarea id="productDescription" name="productDescription" placeholder="Enter detailed product description..." required></textarea>
                </div>

                <!-- Image Compression Settings -->
                <div class="form-group">
                    <div class="compression-settings">
                        <h3>
                            <i class="fas fa-compress-alt"></i>
                            Image Compression Settings
                        </h3>
                        
                        <div class="compression-toggle">
                            <input type="checkbox" id="enableCompression" checked>
                            <label for="enableCompression">Enable Compression</label>
                        </div>
                        
                        <div class="compression-options" id="compressionOptions">
                            <div class="compression-option">
                                <label for="compressionQuality">Quality: <span id="qualityValue">0.15</span> (<span id="qualityPercent">15%</span>)</label>
                                <input type="range" id="compressionQuality" min="0.1" max="0.95" step="0.05" value="0.15">
                                <small>0.1 = Smallest files, 0.95 = Best quality</small>
                            </div>
                            
                            <div class="compression-option">
                                <label for="outputFormat">Output Format</label>
                                <select id="outputFormat">
                                    <option value="jpeg">JPEG (Smaller files)</option>
                                    <option value="png">PNG (Preserve transparency)</option>
                                    <option value="webp">WebP (Best compression)</option>
                                </select>
                                <small>Choose based on your needs</small>
                            </div>
                        </div>
                        
                        <div class="compression-info">
                            <i class="fas fa-info-circle"></i>
                            Compression reduces file sizes for faster uploads and better website performance. Original images are processed in your browser - no data leaves your device during compression.
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>Product Images (Multiple)</label>
                    <div class="multi-image-container" id="multiImageContainer">
                        <i class="fas fa-cloud-upload-alt" style="font-size: 3em; color: #667eea; margin-bottom: 15px; display: block;"></i>
                        <h3>Drag and Drop Images Here</h3>
                        <p>or <strong>click to browse</strong> • Upload multiple images • Compression settings applied automatically</p>
                        <input type="file" id="multiImageInput" multiple accept="image/*" style="display: none;" required>
                        
                        <div class="compression-progress" id="compressionProgress">
                            <div class="compression-progress-bar" id="compressionProgressBar"></div>
                        </div>
                    </div>
                    <div class="image-grid" id="imageGrid">
                        <!-- Selected images will appear here -->
                    </div>
                </div>

                <button type="submit" class="submit-btn" id="submitBtn">
                    <i class="fas fa-plus"></i> Add Product
                </button>
            </form>

            <div class="loading" id="loading">
                <i class="fas fa-spinner"></i>
                <p>Adding product...</p>
            </div>

            <div class="success-message" id="successMessage">
                <i class="fas fa-check-circle"></i> Product added successfully!
            </div>

            <div class="error-message" id="errorMessage">
                <i class="fas fa-exclamation-triangle"></i> <span id="errorText">Something went wrong!</span>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>

    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-storage-compat.js"></script>

    <!-- Cache Invalidation System -->
    <script src="js/cache-invalidator.js"></script>

    <!-- Verification Modal -->
    <div id="verificationModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 20000; display: flex; align-items: center; justify-content: center;">
        <div style="background: white; padding: 40px; border-radius: 12px; text-align: center; max-width: 400px; width: 90%; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);">
            <div style="margin-bottom: 30px;">
                <i class="fas fa-shield-alt" style="font-size: 48px; color: #2563eb; margin-bottom: 15px;"></i>
                <h2 style="margin: 0 0 10px 0; color: #1e293b; font-size: 24px;">Product Admin Access</h2>
                <p style="margin: 0; color: #64748b;">Enter the 4-digit verification code to access product management</p>
            </div>
            
            <div style="margin-bottom: 25px;">
                <input type="password" id="verificationCode" placeholder="Enter 4-digit code" maxlength="4" 
                       style="width: 200px; padding: 15px; border: 2px solid #e2e8f0; border-radius: 8px; text-align: center; font-size: 18px; font-weight: bold; letter-spacing: 3px;" 
                       oninput="handleCodeInput(this)" onkeydown="handleCodeKeydown(event)">
            </div>
            
            <div id="verificationError" style="color: #dc2626; margin-bottom: 20px; font-size: 14px; display: none;">
                <i class="fas fa-exclamation-triangle"></i> Incorrect verification code. Please try again.
            </div>
            
            <button onclick="verifyCode()" style="background: #2563eb; color: white; border: none; padding: 12px 30px; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                <i class="fas fa-unlock"></i> Verify Access
            </button>
            
            <div style="margin-top: 20px; font-size: 12px; color: #94a3b8;">
                Authorized personnel only
            </div>
        </div>
    </div>

    <script>
        // Admin verification system for products panel
        const ADMIN_CODE = '5634';
        const SESSION_KEY = 'adminVerified';
        const SESSION_DURATION = 24 * 60 * 60 * 1000; // 24 hours

        // Check if user should skip verification (coming from verified admin-panel)
        function checkBypassVerification() {
            const fromAdminPanel = sessionStorage.getItem('fromAdminPanel');
            const adminVerified = sessionStorage.getItem('adminVerified');
            const adminVerifyTime = sessionStorage.getItem('adminVerifyTime');
            
            if (fromAdminPanel === 'true' && adminVerified === 'true' && adminVerifyTime) {
                const verifyTime = parseInt(adminVerifyTime);
                const now = Date.now();
                
                // Check if verification is still valid (within 1 hour)
                if (now - verifyTime < 60 * 60 * 1000) {
                    console.log('✅ Bypassing verification - user came from verified admin panel');
                    
                    // Clear session flags
                    sessionStorage.removeItem('fromAdminPanel');
                    sessionStorage.removeItem('adminVerified');
                    sessionStorage.removeItem('adminVerifyTime');
                    
                    // Save to localStorage for this panel
                    localStorage.setItem(SESSION_KEY, JSON.stringify({
                        timestamp: Date.now(),
                        verified: true
                    }));
                    
                    return true;
                }
            }
            
            return false;
        }

        // Check if already verified in localStorage
        function checkAdminSession() {
            // First check if we should bypass verification
            if (checkBypassVerification()) {
                document.getElementById('verificationModal').style.display = 'none';
                return true;
            }
            
            // Check localStorage session
            const session = localStorage.getItem(SESSION_KEY);
            if (session) {
                const sessionData = JSON.parse(session);
                const now = Date.now();
                if (now - sessionData.timestamp < SESSION_DURATION) {
                    // Session is valid, hide modal
                    document.getElementById('verificationModal').style.display = 'none';
                    return true;
                } else {
                    // Session expired
                    localStorage.removeItem(SESSION_KEY);
                }
            }
            return false;
        }

        // Verify the entered code
        function verifyCode() {
            const enteredCode = document.getElementById('verificationCode').value;
            const errorDiv = document.getElementById('verificationError');
            
            if (enteredCode === ADMIN_CODE) {
                // Save session
                localStorage.setItem(SESSION_KEY, JSON.stringify({
                    timestamp: Date.now(),
                    verified: true
                }));
                
                // Hide modal
                document.getElementById('verificationModal').style.display = 'none';
                
                // Show success message briefly
                showSuccessMessage();
            } else {
                // Show error
                errorDiv.style.display = 'block';
                document.getElementById('verificationCode').value = '';
                document.getElementById('verificationCode').style.borderColor = '#dc2626';
                document.getElementById('verificationCode').focus();
                
                // Reset border color after 2 seconds
                setTimeout(() => {
                    document.getElementById('verificationCode').style.borderColor = '#e2e8f0';
                    errorDiv.style.display = 'none';
                }, 2000);
            }
        }

        // Handle code input (auto-format and limit to 4 digits)
        function handleCodeInput(input) {
            input.value = input.value.replace(/[^0-9]/g, '').substring(0, 4);
            
            // Auto-verify when 4 digits are entered
            if (input.value.length === 4) {
                setTimeout(() => verifyCode(), 200);
            }
        }

        // Handle enter key
        function handleCodeKeydown(event) {
            if (event.key === 'Enter') {
                verifyCode();
            }
        }

        // Show success message
        function showSuccessMessage() {
            const successDiv = document.createElement('div');
            successDiv.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 25000;
                background: #059669; color: white; padding: 15px 20px;
                border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
                font-weight: 600; display: flex; align-items: center; gap: 8px;
            `;
            successDiv.innerHTML = '<i class="fas fa-check-circle"></i> Product admin access granted!';
            document.body.appendChild(successDiv);
            
            setTimeout(() => {
                successDiv.remove();
            }, 3000);
        }

        // Initialize verification check
        window.addEventListener('DOMContentLoaded', () => {
            if (!checkAdminSession()) {
                // Focus on input after modal is shown
                setTimeout(() => {
                    document.getElementById('verificationCode').focus();
                }, 100);
            }
        });

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCrLCButDevLeILcBjrUCd9e7amXVjW-uI",
            authDomain: "auric-a0c92.firebaseapp.com",
            projectId: "auric-a0c92",
            storageBucket: "auric-a0c92.firebasestorage.app",
            messagingSenderId: "878979958342",
            appId: "1:878979958342:web:e6092f7522488d21eaec47",
            measurementId: "G-ZYZ750JHMB"
        };

        // Initialize Firebase with error handling
        let app, storage;
        try {
            // Check if Firebase is already initialized
            try {
                app = firebase.app();
                console.log('Using existing Firebase app');
            } catch (e) {
                if (e.code === 'app-compat/no-app') {
                    app = firebase.initializeApp(firebaseConfig);
                    console.log('Initialized new Firebase app');
                } else {
                    throw e;
                }
            }
            storage = firebase.storage();
        } catch (error) {
            console.error('Firebase initialization failed:', error);
            showError('Firebase initialization failed. Please check your connection and try again.');
        }


        // Test Firebase connection with retry logic
        async function testFirebaseConnection(retryCount = 0) {
            const maxRetries = 3;
            try {
                console.log(`Testing Firebase connection... (attempt ${retryCount + 1})`);
                console.log('Firebase config:', {
                    projectId: firebaseConfig.projectId,
                    storageBucket: firebaseConfig.storageBucket
                });

                if (!storage) {
                    throw new Error('Firebase Storage not initialized');
                }

                // Skip Firestore test - using Cloud Storage only
                console.log('✅ Firestore connection skipped (using Cloud Storage only)');

                // Test Storage connection with timeout and retry
                console.log('Testing Firebase Storage connection...');
                await Promise.race([
                    storage.ref().child('test').getMetadata().catch(() => console.log('Test file not found (normal)')),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Storage timeout')), 10000))
                ]);
                console.log('✅ Firebase Storage connection successful');

                return true;
            } catch (error) {
                console.error(`❌ Firebase connection failed (attempt ${retryCount + 1}):`, error);

                // Retry logic
                if (retryCount < maxRetries - 1) {
                    console.log(`Retrying in 2 seconds... (${retryCount + 1}/${maxRetries})`);
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    return testFirebaseConnection(retryCount + 1);
                }

                // Show connection error to user after all retries
                const errorMessage = document.getElementById('errorMessage');
                const errorText = document.getElementById('errorText');

                if (error.code === 'permission-denied') {
                    errorText.textContent = 'Firebase permission denied. Please check your security rules.';
                } else if (error.code === 'failed-precondition') {
                    errorText.textContent = 'Firebase setup issue. Please check your configuration.';
                } else if (error.message.includes('timeout')) {
                    errorText.textContent = 'Firebase connection timeout. Please check your internet connection and try again.';
                } else if (error.message.includes('not initialized')) {
                    errorText.textContent = 'Firebase initialization failed. Please refresh the page.';
                } else {
                    errorText.textContent = `Firebase connection error: ${error.message}`;
                }

                errorMessage.style.display = 'block';
                return false;
            }
        }

        // Handle URL parameters for category pre-selection
        function handleURLParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const category = urlParams.get('category');
            const editProductId = urlParams.get('edit');
            
            if (category) {
                console.log('Pre-selecting category from URL:', category);
                const categorySelect = document.getElementById('productCategory');
                if (categorySelect) {
                    categorySelect.value = category;
                    console.log('Category pre-selected:', category);
                }
            }
            
            if (editProductId) {
                console.log('Edit mode detected for product:', editProductId);
                // Handle edit mode if needed
            }
        }

        // Show compression summary after processing multiple images
        function showCompressionSummary(images) {
            const compressedImages = images.filter(img => img.isCompressed);
            
            if (compressedImages.length === 0) return;
            
            const totalOriginalSize = compressedImages.reduce((sum, img) => sum + img.originalSize, 0);
            const totalCompressedSize = compressedImages.reduce((sum, img) => sum + img.compressedSize, 0);
            const totalSavings = totalOriginalSize - totalCompressedSize;
            const averageSavings = (totalSavings / totalOriginalSize * 100).toFixed(1);
            
            // Create summary notification
            const summaryDiv = document.createElement('div');
            summaryDiv.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 25000;
                background: linear-gradient(135deg, #10b981, #059669);
                color: white; padding: 20px 25px; border-radius: 12px;
                box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                max-width: 320px; animation: slideIn 0.3s ease-out;
            `;
            
            summaryDiv.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                    <i class="fas fa-compress-alt" style="font-size: 20px;"></i>
                    <strong style="font-size: 16px;">Images Compressed!</strong>
                </div>
                <div style="font-size: 14px; opacity: 0.95; line-height: 1.4;">
                    <div>✅ <strong>${compressedImages.length}</strong> images compressed</div>
                    <div>📁 Total savings: <strong>${formatFileSize(totalSavings)}</strong></div>
                    <div>🎯 Average reduction: <strong>${averageSavings}%</strong></div>
                    <div style="margin-top: 8px; font-size: 12px; opacity: 0.8;">
                        ${formatFileSize(totalOriginalSize)} → ${formatFileSize(totalCompressedSize)}
                    </div>
                </div>
                <button onclick="this.parentElement.remove()" 
                        style="position: absolute; top: 8px; right: 8px; background: none; 
                               border: none; color: white; font-size: 18px; cursor: pointer; 
                               width: 24px; height: 24px; border-radius: 50%; 
                               display: flex; align-items: center; justify-content: center;"
                        title="Close">×</button>
            `;
            
            // Add slide-in animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(summaryDiv);
            
            // Auto-remove after 8 seconds
            setTimeout(() => {
                if (summaryDiv.parentElement) {
                    summaryDiv.style.transition = 'all 0.3s ease-out';
                    summaryDiv.style.transform = 'translateX(100%)';
                    summaryDiv.style.opacity = '0';
                    setTimeout(() => summaryDiv.remove(), 300);
                }
            }, 8000);
        }

        // Test connection when page loads
        document.addEventListener('DOMContentLoaded', async function() {
            // Handle URL parameters first
            handleURLParameters();
            
            // Initialize compression settings
            initializeCompressionSettings();
            
            // Check network connectivity first
            if (!navigator.onLine) {
                showError('No internet connection. Please check your network and try again.');
                return;
            }

            // Add network status listeners
            window.addEventListener('online', () => {
                console.log('Network reconnected');
                location.reload(); // Refresh page when network comes back
            });

            window.addEventListener('offline', () => {
                console.log('Network disconnected');
                showError('Internet connection lost. Please check your network.');
            });

            // Test Firebase connection with better error handling
            const connectionSuccess = await testFirebaseConnection();
            if (connectionSuccess) {
                initializeEditMode();
            } else {
                // Disable form submission if Firebase connection failed
                const submitBtn = document.getElementById('submitBtn');
                if (submitBtn) {
                    submitBtn.disabled = true;
                    submitBtn.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Connection Failed';
                }
            }
        });

        // Initialize compression settings on page load
        function initializeCompressionSettings() {
            console.log('⚙️ Initializing image compression system...');
            
            // Set default values and initialize UI state
            const enableCompression = document.getElementById('enableCompression');
            const compressionOptions = document.getElementById('compressionOptions');
            
            if (enableCompression.checked) {
                compressionOptions.classList.remove('compression-disabled');
            }
            
            console.log('✅ Image compression system ready');
            console.log('Compression settings:', {
                enabled: enableCompression.checked,
                quality: document.getElementById('compressionQuality').value,
                format: document.getElementById('outputFormat').value
            });
        }

        // Initialize edit mode if URL parameters are present
        function initializeEditMode() {
            const urlParams = new URLSearchParams(window.location.search);
            const editId = urlParams.get('edit');
            const category = urlParams.get('category');

            if (editId && category) {
                loadProductForEdit(editId, category);
            }
        }

        // Load product data for editing
        async function loadProductForEdit(productId, category) {
            try {
                console.log(`Loading product ${productId} from ${category} for editing...`);

                // Set edit mode variables
                isEditMode = true;
                editProductId = productId;
                editCategory = category;
                originalProductData = null; // Store original data for comparison

                // Update UI for edit mode
                document.querySelector('.admin-header h1').innerHTML = '<i class="fas fa-edit"></i> Edit Product';
                document.querySelector('.admin-header p').textContent = `Editing ${category} product`;
                document.getElementById('submitBtn').innerHTML = '<i class="fas fa-save"></i> Update Product';

                // Show loading state
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').innerHTML = `
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>Loading product data for editing...</p>
                `;

                // Load products data
                const response = await fetch(`/.netlify/functions/load-products?category=${category}&cacheBust=${Date.now()}`);
                const data = await response.json();

                if (data.success && data.products) {
                    const product = data.products.find(p => p.id === productId);

                    if (product) {
                        // Store original product data for reference
                        originalProductData = JSON.parse(JSON.stringify(product));

                        // Populate form fields
                        document.getElementById('productName').value = product.name || '';
                        document.getElementById('productPrice').value = product.price || '';
                        document.getElementById('productStock').value = product.stock || 0;
                        document.getElementById('productDescription').value = product.description || '';
                        document.getElementById('productCategory').value = category;

                        // Remove required attributes in edit mode to allow partial updates
                        document.getElementById('productName').removeAttribute('required');
                        document.getElementById('productPrice').removeAttribute('required');
                        document.getElementById('productStock').removeAttribute('required');
                        document.getElementById('productDescription').removeAttribute('required');
                        document.getElementById('productCategory').removeAttribute('required');
                        document.getElementById('multiImageInput').removeAttribute('required');

                        // Load existing images - convert URLs to a format that works with the display system
                        if (product.images && Array.isArray(product.images)) {
                            // Convert existing image URLs to objects that work with the display system
                            selectedImages = product.images.map(img => ({
                                existingUrl: img.url,
                                url: img.url,
                                isMain: img.isMain,
                                alt: img.alt || product.name,
                                name: img.alt || `${product.name} - Image`,
                                isExisting: true // Mark as existing image
                            }));
                            mainImageIndex = product.images.findIndex(img => img.isMain);
                            if (mainImageIndex === -1) mainImageIndex = 0;
                            
                            // Cache the image URLs for display
                            selectedImages.forEach(img => {
                                imageCache.set(img, img.url);
                            });
                            
                            displayImageGrid();
                        } else if (product.mainImage) {
                            // Handle single image products
                            const imageObj = {
                                existingUrl: product.mainImage,
                                url: product.mainImage,
                                isMain: true,
                                alt: product.name,
                                name: `${product.name} - Main Image`,
                                isExisting: true
                            };
                            selectedImages = [imageObj];
                            mainImageIndex = 0;
                            
                            // Cache the image URL
                            imageCache.set(imageObj, product.mainImage);
                            displayImageGrid();
                        }

                        console.log('Product loaded for editing:', product);
                        console.log('Edit mode set:', isEditMode, 'Product ID:', editProductId, 'Category:', editCategory);
                    } else {
                        throw new Error('Product not found');
                    }
                } else {
                    throw new Error('Failed to load product data');
                }

                document.getElementById('loading').style.display = 'none';

            } catch (error) {
                console.error('Error loading product for edit:', error);
                document.getElementById('loading').style.display = 'none';
                showError(`Failed to load product: ${error.message}`);

                // Reset edit mode on error
                isEditMode = false;
                editProductId = null;
                editCategory = null;
                originalProductData = null;
                
                // Reset UI
                document.querySelector('.admin-header h1').innerHTML = 'Nazakat Admin Panel';
                document.querySelector('.admin-header p').textContent = 'Product Management System';
                document.getElementById('submitBtn').innerHTML = '<i class="fas fa-plus"></i> Add Product';
            }
        }

        // DOM elements
        const productForm = document.getElementById('productForm');
        const submitBtn = document.getElementById('submitBtn');
        const loading = document.getElementById('loading');
        const successMessage = document.getElementById('successMessage');
        const errorMessage = document.getElementById('errorMessage');
        const errorText = document.getElementById('errorText');
        const multiImageContainer = document.getElementById('multiImageContainer');
        const multiImageInput = document.getElementById('multiImageInput');
        const imageGrid = document.getElementById('imageGrid');

        // Store selected images
        let selectedImages = [];
        let mainImageIndex = 0;
        let imageCache = new Map(); // Cache for loaded image data URLs

        // Global variables for edit mode
        let isEditMode = false;
        let editProductId = null;
        let editCategory = null;
        let originalProductData = null;

        // Multi-image functionality
        multiImageContainer.addEventListener('click', () => {
            multiImageInput.click();
        });

        multiImageContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            multiImageContainer.classList.add('dragover');
        });

        multiImageContainer.addEventListener('dragleave', (e) => {
            e.preventDefault();
            multiImageContainer.classList.remove('dragover');
        });

        multiImageContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            multiImageContainer.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files);
            handleImageFiles(files);
        });

        multiImageInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            handleImageFiles(files);
        });

        // Compression Settings Event Listeners
        const enableCompressionCheckbox = document.getElementById('enableCompression');
        const compressionOptions = document.getElementById('compressionOptions');
        const qualitySlider = document.getElementById('compressionQuality');
        const qualityValue = document.getElementById('qualityValue');
        const compressionProgress = document.getElementById('compressionProgress');
        const compressionProgressBar = document.getElementById('compressionProgressBar');

        // Toggle compression options visibility
        enableCompressionCheckbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                compressionOptions.classList.remove('compression-disabled');
            } else {
                compressionOptions.classList.add('compression-disabled');
            }
        });

        // Update quality value display
        const qualityPercent = document.getElementById('qualityPercent');
        qualitySlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            qualityValue.textContent = value;
            qualityPercent.textContent = Math.round(value * 100) + '%';
        });

        // IMAGE COMPRESSION FUNCTIONS

        /**
         * Compress a single image using HTML5 Canvas API
         * @param {File} file - The image file to compress
         * @param {Object} options - Compression options
         * @returns {Promise<File>} - Compressed image file
         */
        async function compressImage(file, options = {}) {
            return new Promise((resolve, reject) => {
                const {
                    quality = 0.8,
                    format = 'jpeg'
                } = options;

                // Create image element
                const img = new Image();
                img.onload = function() {
                    try {
                        // Use original dimensions - no resizing
                        const width = img.naturalWidth;
                        const height = img.naturalHeight;

                        // Create canvas
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Set canvas dimensions to original size
                        canvas.width = width;
                        canvas.height = height;

                        // Enable image smoothing for better quality
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';

                        // Draw image to canvas at original size
                        ctx.drawImage(img, 0, 0, width, height);

                        // Convert to blob with compression
                        const mimeType = format === 'png' ? 'image/png' : 
                                       format === 'webp' ? 'image/webp' : 'image/jpeg';
                        
                        canvas.toBlob((blob) => {
                            if (!blob) {
                                reject(new Error('Canvas compression failed'));
                                return;
                            }

                            // Create new File object with compressed data
                            const compressedFile = new File([blob], file.name, {
                                type: mimeType,
                                lastModified: Date.now()
                            });

                            // Add compression metadata
                            compressedFile.originalSize = file.size;
                            compressedFile.compressedSize = blob.size;
                            compressedFile.compressionRatio = ((file.size - blob.size) / file.size * 100).toFixed(1);
                            compressedFile.isCompressed = true;
                            compressedFile.originalDimensions = {
                                width: img.naturalWidth,
                                height: img.naturalHeight
                            };
                            compressedFile.newDimensions = { width, height };

                            resolve(compressedFile);
                        }, mimeType, quality);

                    } catch (error) {
                        reject(error);
                    }
                };

                img.onerror = () => {
                    reject(new Error('Failed to load image for compression'));
                };

                // Load image from file
                img.src = URL.createObjectURL(file);
            });
        }


        /**
         * Format file size for display
         */
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        /**
         * Show compression progress
         */
        function showCompressionProgress(current, total) {
            const progress = (current / total) * 100;
            compressionProgress.style.display = 'block';
            compressionProgressBar.style.width = progress + '%';
            
            // Update container message
            const container = document.querySelector('#multiImageContainer h3');
            if (container) {
                container.textContent = `Compressing Images... ${current}/${total}`;
            }
        }

        /**
         * Hide compression progress
         */
        function hideCompressionProgress() {
            compressionProgress.style.display = 'none';
            compressionProgressBar.style.width = '0%';
            
            // Reset container message
            const container = document.querySelector('#multiImageContainer h3');
            if (container) {
                container.textContent = 'Drag and Drop Images Here';
            }
        }

        async function handleImageFiles(files) {
            const imageFiles = files.filter(file => file.type.startsWith('image/'));

            if (imageFiles.length === 0) {
                showError('Please select valid image files.');
                return;
            }

            console.log(`Processing ${imageFiles.length} new images...`);

            let processedImages = [];
            
            // Check if compression is enabled
            const compressionEnabled = document.getElementById('enableCompression').checked;
            
            if (compressionEnabled) {
                try {
                    // Get compression settings
                    const compressionSettings = {
                        quality: parseFloat(document.getElementById('compressionQuality').value),
                        format: document.getElementById('outputFormat').value
                    };

                    console.log('Compression enabled with settings:', compressionSettings);
                    
                    // Show progress
                    showCompressionProgress(0, imageFiles.length);

                    // Compress each image
                    for (let i = 0; i < imageFiles.length; i++) {
                        const file = imageFiles[i];
                        console.log(`Compressing image ${i + 1}/${imageFiles.length}: ${file.name}`);
                        
                        try {
                            const compressedFile = await compressImage(file, compressionSettings);
                            processedImages.push(compressedFile);
                            
                            // Log compression results
                            console.log(`✅ Compressed ${file.name}:`, {
                                original: formatFileSize(compressedFile.originalSize),
                                compressed: formatFileSize(compressedFile.compressedSize),
                                savings: compressedFile.compressionRatio + '%',
                                dimensions: `${compressedFile.originalDimensions.width}x${compressedFile.originalDimensions.height} → ${compressedFile.newDimensions.width}x${compressedFile.newDimensions.height}`
                            });
                            
                            showCompressionProgress(i + 1, imageFiles.length);
                        } catch (error) {
                            console.warn(`Compression failed for ${file.name}, using original:`, error);
                            // Use original file if compression fails
                            file.isCompressed = false;
                            processedImages.push(file);
                        }
                    }

                    hideCompressionProgress();
                    console.log(`✅ Image compression completed. ${processedImages.length} images processed.`);
                    
                } catch (error) {
                    console.error('Compression process failed:', error);
                    hideCompressionProgress();
                    showError('Image compression failed. Using original images.');
                    processedImages = [...imageFiles];
                }
            } else {
                // No compression, use original files
                console.log('Compression disabled, using original images');
                processedImages = [...imageFiles];
            }

            // Add processed images to existing array
            selectedImages = [...selectedImages, ...processedImages];
            console.log(`Added ${processedImages.length} new images. Total images: ${selectedImages.length}`);

            // Pre-load all processed images into cache
            const loadPromises = processedImages.map((file) => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        imageCache.set(file, e.target.result);
                        resolve();
                    };
                    reader.readAsDataURL(file);
                });
            });

            // Display grid after all images are cached
            Promise.all(loadPromises).then(() => {
                displayImageGrid();
                
                // Show compression summary if any images were compressed
                if (compressionEnabled) {
                    showCompressionSummary(processedImages);
                }
            });
        }

        function displayImageGrid() {
            // Clear the grid completely
            imageGrid.innerHTML = '';

            if (selectedImages.length === 0) {
                console.log('No images to display');
                return;
            }

            console.log(`Displaying ${selectedImages.length} images in horizontal order: (Main-1), 2, 3, 4, 5, 6...`);
            console.log(`Main image is at position ${mainImageIndex + 1}`);

            // Create all image items - handle both File objects and existing URLs
            selectedImages.forEach((file, index) => {
                const cachedDataUrl = imageCache.get(file);

                if (cachedDataUrl) {
                    // Use cached image data - instant display, no blank spaces
                    const imageItem = createImageItem(cachedDataUrl, index, file.name || file.alt || file);
                    imageItem.style.order = index; // Ensure correct flex order
                    imageGrid.appendChild(imageItem);

                    // Log current position for debugging
                    const displayPos = index + 1;
                    const isMain = index === mainImageIndex;
                    const fileName = file.name || file.alt || 'Unknown';
                    console.log(`Position ${displayPos}: ${fileName} ${isMain ? '(MAIN)' : ''}`);
                } else if (file.existingUrl || file.url) {
                    // Handle existing image URLs (edit mode) - no FileReader needed
                    const imageUrl = file.existingUrl || file.url;
                    const fileName = file.name || file.alt || 'Existing Image';
                    
                    // Cache the URL for consistency
                    imageCache.set(file, imageUrl);
                    
                    const imageItem = createImageItem(imageUrl, index, fileName);
                    imageItem.style.order = index;
                    imageGrid.appendChild(imageItem);
                    
                    console.log(`Position ${index + 1}: ${fileName} (existing URL) ${index === mainImageIndex ? '(MAIN)' : ''}`);
                } else {
                    // Handle new file uploads that need FileReader
                    console.log(`Loading new file: ${file.name}`);
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        imageCache.set(file, e.target.result);
                        const imageItem = createImageItem(e.target.result, index, file.name);
                        imageItem.style.order = index;
                        imageGrid.appendChild(imageItem);
                    };
                    reader.onerror = (e) => {
                        console.error('FileReader error:', e);
                        showError('Error reading image file');
                    };
                    reader.readAsDataURL(file);
                }
            });

            console.log('✅ Image grid updated with horizontal layout: (Main-1), 2, 3, 4, 5, 6...');
        }

        function createImageItem(src, index, fileName) {
            const div = document.createElement('div');
            const isMainImage = index === mainImageIndex;

            // Set proper classes including main image highlight
            div.className = `image-item ${isMainImage ? 'main-image' : ''}`;
            div.draggable = true;
            div.dataset.index = index;

            // Calculate display position (1-based)
            const displayPosition = index + 1;

            // Create position options for dropdown
            let positionOptions = '';
            for (let i = 1; i <= selectedImages.length; i++) {
                positionOptions += `<option value="${i}" ${i === displayPosition ? 'selected' : ''}>${i}</option>`;
            }

            // Position label shows actual position in sequence
            const positionLabel = isMainImage ? `Main-${displayPosition}` : `${displayPosition}`;
            const positionClass = isMainImage ? 'main' : '';

            // Get display name - handle both file objects and existing images
            let displayName = fileName;
            if (typeof fileName === 'string' && fileName.length > 20) {
                displayName = fileName.substring(0, 17) + '...';
            } else if (typeof fileName === 'object' && fileName.name) {
                displayName = fileName.name.length > 20 ? fileName.name.substring(0, 17) + '...' : fileName.name;
            } else if (typeof fileName === 'object' && fileName.alt) {
                displayName = fileName.alt.length > 20 ? fileName.alt.substring(0, 17) + '...' : fileName.alt;
            }

            // Check if this is a compressed image
            const imageFile = selectedImages[index];
            const isCompressed = imageFile && imageFile.isCompressed;
            
            // Add compressed class if applicable
            if (isCompressed) {
                div.classList.add('compressed');
            }
            
            // Create compression info for display
            let compressionInfo = '';
            let compressionBadge = '';
            
            if (isCompressed && imageFile.compressionRatio) {
                compressionBadge = `<div class="compression-badge">-${imageFile.compressionRatio}%</div>`;
                
                const originalSize = formatFileSize(imageFile.originalSize);
                const compressedSize = formatFileSize(imageFile.compressedSize);
                const originalDim = imageFile.originalDimensions;
                const newDim = imageFile.newDimensions;
                
                compressionInfo = `\n                    <div style="font-size: 10px; color: #059669; margin-top: 2px;">
                        ✅ ${originalSize} → ${compressedSize}<br>
                        ${originalDim.width}×${originalDim.height} (no resize)
                    </div>`;
            }

            div.innerHTML = `
                <img src="${src}" alt="${displayName}">

                <!-- Position label showing current order -->
                <div class="position-label ${positionClass}">
                    ${positionLabel}
                </div>

                <!-- Compression badge -->
                ${compressionBadge}

                <!-- Image controls for main/remove -->
                <div class="image-controls">
                    ${isMainImage ?
                        '<button type="button" class="control-btn main">MAIN</button>' :
                        '<button type="button" class="control-btn" onclick="setMainImage(' + index + ')">Set Main</button>'
                    }
                    <button type="button" class="control-btn" onclick="removeImage(${index})">×</button>
                </div>

                <!-- Position controls for ordering -->
                <div class="image-position-controls">
                    <button type="button" class="position-btn" onclick="moveImage(${index}, 'up')"
                            ${index === 0 ? 'disabled' : ''} title="Move Left">←</button>
                    <select class="position-select" onchange="moveToPosition(${index}, this.value)" title="Change Position">
                        ${positionOptions}
                    </select>
                    <button type="button" class="position-btn" onclick="moveImage(${index}, 'down')"
                            ${index === selectedImages.length - 1 ? 'disabled' : ''} title="Move Right">→</button>
                </div>

                <div class="image-info">
                    ${displayName}${compressionInfo}
                </div>
            `;

            // Add drag and drop event listeners for reordering
            div.addEventListener('dragstart', handleDragStart);
            div.addEventListener('dragover', handleDragOver);
            div.addEventListener('drop', handleDrop);
            div.addEventListener('dragenter', handleDragEnter);
            div.addEventListener('dragleave', handleDragLeave);

            return div;
        }

        function setMainImage(index) {
            // Set main image without changing position
            mainImageIndex = index;
            console.log(`✅ Set main image to position ${index + 1}`);
            displayImageGrid();
        }

        function removeImage(index) {
            console.log(`Removing image at position ${index + 1}`);
            selectedImages.splice(index, 1);

            // Adjust main image index if needed
            if (mainImageIndex >= selectedImages.length) {
                mainImageIndex = 0;
            } else if (mainImageIndex > index) {
                mainImageIndex--;
            }

            console.log(`After removal: ${selectedImages.length} images remaining, main at position ${mainImageIndex + 1}`);
            displayImageGrid();
        }

        // IMAGE REORDERING FUNCTIONS - Core Logic

        function moveImage(currentIndex, direction) {
            console.log(`Moving image from position ${currentIndex + 1} ${direction}`);

            if (direction === 'up' && currentIndex > 0) {
                // Move left (swap with previous)
                const targetIndex = currentIndex - 1;
                swapImages(currentIndex, targetIndex);
                console.log(`✅ Moved image from position ${currentIndex + 1} to ${targetIndex + 1}`);

            } else if (direction === 'down' && currentIndex < selectedImages.length - 1) {
                // Move right (swap with next)
                const targetIndex = currentIndex + 1;
                swapImages(currentIndex, targetIndex);
                console.log(`✅ Moved image from position ${currentIndex + 1} to ${targetIndex + 1}`);
            }

            displayImageGrid();
        }

        function moveToPosition(currentIndex, newPosition) {
            const targetIndex = parseInt(newPosition) - 1; // Convert to 0-based

            if (targetIndex === currentIndex || targetIndex < 0 || targetIndex >= selectedImages.length) {
                console.log('No position change needed');
                return;
            }

            console.log(`Swapping image from position ${currentIndex + 1} with image at position ${newPosition}`);

            // SWAP the images instead of moving
            swapImages(currentIndex, targetIndex);

            console.log(`✅ Images swapped! Position ${currentIndex + 1} ↔ Position ${targetIndex + 1}`);
            displayImageGrid();
        }

        function swapImages(index1, index2) {
            // Swap images in array
            [selectedImages[index1], selectedImages[index2]] = [selectedImages[index2], selectedImages[index1]];

            // Update main image index if either swapped image was main
            if (mainImageIndex === index1) {
                mainImageIndex = index2;
            } else if (mainImageIndex === index2) {
                mainImageIndex = index1;
            }
        }

        function updateMainImageIndexAfterMove(oldIndex, newIndex) {
            if (mainImageIndex === oldIndex) {
                // The main image itself was moved
                mainImageIndex = newIndex;
            } else if (oldIndex < mainImageIndex && newIndex >= mainImageIndex) {
                // Image moved from before main to after main
                mainImageIndex--;
            } else if (oldIndex > mainImageIndex && newIndex <= mainImageIndex) {
                // Image moved from after main to before main
                mainImageIndex++;
            }
        }

        // DRAG AND DROP FUNCTIONALITY

        let draggedIndex = null;

        function handleDragStart(e) {
            draggedIndex = parseInt(e.currentTarget.dataset.index);
            e.currentTarget.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            console.log(`Started dragging image at position ${draggedIndex + 1}`);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            if (e.currentTarget.dataset.index !== draggedIndex.toString()) {
                e.currentTarget.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            const dropIndex = parseInt(e.currentTarget.dataset.index);

            if (draggedIndex !== null && draggedIndex !== dropIndex) {
                console.log(`Dropping image from position ${draggedIndex + 1} to position ${dropIndex + 1}`);

                // Move the dragged image to the drop position
                const draggedImage = selectedImages[draggedIndex];
                selectedImages.splice(draggedIndex, 1);
                selectedImages.splice(dropIndex, 0, draggedImage);

                // Update main image index
                updateMainImageIndexAfterMove(draggedIndex, dropIndex);

                console.log(`✅ Drag and drop completed! Main image now at position ${mainImageIndex + 1}`);
                displayImageGrid();
            }

            // Clean up drag states
            draggedIndex = null;
            document.querySelectorAll('.image-item').forEach(item => {
                item.classList.remove('dragging', 'drag-over');
            });
        }

        // Generate unique product ID
        function generateProductId(category, name, price) {
            const timestamp = Date.now();
            const randomStr = Math.random().toString(36).substring(2, 10);
            const microTime = performance.now().toString().replace('.', '');
            const prefix = category.toUpperCase().substring(0, 3);
            return `${prefix}-${timestamp}-${randomStr}-${microTime}`;
        }

        // Show error message
        function showError(message) {
            errorText.textContent = message;
            errorMessage.style.display = 'block';
            setTimeout(() => {
                errorMessage.style.display = 'none';
            }, 5000);
        }

        // Upload multiple images to Firebase Storage
        async function uploadMultipleImages(files, productId) {
            const uploadPromises = files.map((file, index) => {
                const timestamp = Date.now();
                const randomId = Math.random().toString(36).substring(2, 8);
                const fileName = `${productId}_${timestamp}_${index}_${randomId}.jpg`;
                return uploadSingleImage(file, fileName, index, files.length);
            });

            return Promise.all(uploadPromises);
        }

        // Upload single image to Firebase Storage with progress tracking
        async function uploadSingleImage(file, fileName, index, totalFiles) {
            const storageRef = storage.ref(`productImages/${fileName}`);

            return new Promise((resolve, reject) => {
                // Set metadata for 30-day CDN caching
                const metadata = {
                    cacheControl: 'public, max-age=2592000', // 30 days CDN cache
                    contentType: file.type
                };

                const uploadTask = storageRef.put(file, metadata);

                // Track upload progress
                uploadTask.on('state_changed',
                    (snapshot) => {
                        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                        console.log(`Upload progress for image ${index + 1}/${totalFiles}:`, Math.round(progress) + '%');

                        // Update loading message with overall progress
                        const loadingElement = document.getElementById('loading');
                        if (loadingElement) {
                            loadingElement.innerHTML = `
                                <i class="fas fa-spinner fa-spin"></i>
                                <p>Uploading image ${index + 1} of ${totalFiles}... ${Math.round(progress)}%</p>
                                <div style="background: #f0f0f0; height: 10px; border-radius: 5px; margin-top: 10px;">
                                    <div style="background: #2563eb; height: 100%; width: ${progress}%; border-radius: 5px; transition: width 0.3s;"></div>
                                </div>
                            `;
                        }
                    },
                    (error) => {
                        console.error(`Upload error for image ${index + 1}:`, error);
                        reject(error);
                    },
                    async () => {
                        try {
                            console.log('Upload completed, generating image proxy URL...');
                            const downloadURL = await uploadTask.snapshot.ref.getDownloadURL();
                            console.log('Image uploaded successfully to Firebase Storage:', downloadURL);

                            // Generate image proxy URL instead of direct Firebase URL
                            const imagePath = `productImages/${fileName}`;
                            const proxyURL = `/.netlify/functions/image-proxy?path=${encodeURIComponent(imagePath)}`;
                            console.log('Generated image proxy URL:', proxyURL);

                            resolve(proxyURL);
                        } catch (error) {
                            console.error('Error getting download URL:', error);
                            reject(error);
                        }
                    }
                );
            });
        }

        // Update existing product data in Firebase Cloud Storage
        async function updateProductData(productData, category) {
            try {
                // Update loading message
                const loadingElement = document.getElementById('loading');
                if (loadingElement) {
                    loadingElement.innerHTML = `
                        <i class="fas fa-spinner fa-spin"></i>
                        <p>Loading existing products for update...</p>
                    `;
                }

                // Load existing products
                console.log('Loading existing products for update...');
                let existingProducts = [];

                try {
                    const cacheBust = `cacheBust=${Date.now()}`;
                    const apiEndpoint = `/.netlify/functions/load-products?category=${category}&${cacheBust}`;

                    const response = await fetch(apiEndpoint, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        },
                        cache: 'no-store'
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && Array.isArray(data.products)) {
                            existingProducts = data.products;
                            console.log('Successfully loaded', existingProducts.length, 'existing products for update');
                        }
                    }
                } catch (error) {
                    console.warn('Error loading products for update:', error.message);
                    throw new Error('Failed to load existing products for update');
                }

                // Find and update the specific product
                const productIndex = existingProducts.findIndex(p => p.id === productData.id);
                if (productIndex === -1) {
                    throw new Error('Product not found for update');
                }

                // Update the product while preserving createdAt
                const existingProduct = existingProducts[productIndex];
                productData.createdAt = existingProduct.createdAt || new Date().toISOString();
                productData.updatedAt = new Date().toISOString();

                existingProducts[productIndex] = productData;
                console.log('Updated product at index', productIndex);

                // Update loading message
                if (loadingElement) {
                    loadingElement.innerHTML = `
                        <i class="fas fa-spinner fa-spin"></i>
                        <p>Saving updated product to Cloud Storage...</p>
                    `;
                }

                // Save updated list to Firebase Storage
                const jsonData = JSON.stringify(existingProducts, null, 2);
                const blob = new Blob([jsonData], { type: 'application/json' });
                const storageRef = storage.ref(`productData/${category}-products.json`);

                await storageRef.put(blob, {
                    contentType: 'application/json',
                    cacheControl: 'public, max-age=2592000'
                });

                console.log('Product updated successfully in Firebase Storage');
                return true;

            } catch (error) {
                console.error('Error updating product data:', error);
                throw new Error(`Failed to update product: ${error.message}`);
            }
        }

        // Save product data EXCLUSIVELY to Firebase Cloud Storage
        async function saveProductData(productData, category) {
            try {
                // Update loading message
                const loadingElement = document.getElementById('loading');
                if (loadingElement) {
                    loadingElement.innerHTML = `
                        <i class="fas fa-spinner fa-spin"></i>
                        <p>Loading existing products via server...</p>
                    `;
                }

                // Use the server API to load existing products (more reliable)
                console.log('Loading existing products via server API...');
                let existingProducts = [];

                try {
                    // Detect environment and use appropriate endpoint
                    const isNetlify = window.location.hostname.includes('netlify') || window.location.hostname.includes('.app');

                    // ADD CACHE BUSTING FOR ADMIN PANEL - Always get fresh data when adding products
                    const cacheBust = `cacheBust=${Date.now()}`;
                    const separator = isNetlify ? '&' : '?';

                    const apiEndpoint = isNetlify
                        ? `/.netlify/functions/load-products?category=${category}&${cacheBust}`
                        : `/api/load-products/${category}?${cacheBust}`;

                    console.log('Using endpoint with cache busting:', apiEndpoint, '(Netlify:', isNetlify, ')');

                    // Use aggressive cache-busting headers to ensure fresh data
                    const response = await fetch(apiEndpoint, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        },
                        cache: 'no-store' // Force bypass browser cache
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && Array.isArray(data.products)) {
                            existingProducts = data.products;
                            console.log('Successfully loaded', existingProducts.length, 'existing products via server');
                        } else {
                            console.warn('Server returned no products or invalid format');
                            existingProducts = [];
                        }
                    } else {
                        console.warn('Server response not OK:', response.status);
                        existingProducts = [];
                    }
                } catch (error) {
                    console.warn('Error loading products via server:', error.message);
                    console.log('Falling back to direct Firebase access...');

                    // Fallback to direct Firebase Storage access
                    try {
                        const storageRef = storage.ref(`productData/${category}-products.json`);
                        const downloadURL = await storageRef.getDownloadURL();
                        const directResponse = await fetch(downloadURL);

                        if (directResponse.ok) {
                            const data = await directResponse.json();
                            if (Array.isArray(data)) {
                                existingProducts = data;
                                console.log('Fallback: loaded', existingProducts.length, 'products directly');
                            }
                        }
                    } catch (fallbackError) {
                        console.warn('Fallback also failed, starting with empty array');
                        existingProducts = [];
                    }
                }

                // Update loading message
                if (loadingElement) {
                    loadingElement.innerHTML = `
                        <i class="fas fa-spinner fa-spin"></i>
                        <p>Adding new product...</p>
                    `;
                }

                // Check if product already exists (just in case)
                const existingIndex = existingProducts.findIndex(p => p.id === productData.id);
                if (existingIndex >= 0) {
                    console.log('Product with this ID already exists, generating new ID...');
                    productData.id = generateProductId(productData.category, productData.name, productData.price); // Generate new unique ID
                }

                // Add the new product
                existingProducts.push(productData);
                console.log('Added new product with ID', productData.id, 'to existing', existingProducts.length - 1, 'products');

                // Sort products by creation date (newest first)
                existingProducts.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

                console.log('Updated product list now contains', existingProducts.length, 'products');

                // Update loading message
                if (loadingElement) {
                    loadingElement.innerHTML = `
                        <i class="fas fa-spinner fa-spin"></i>
                        <p>Saving to Cloud Storage...</p>
                    `;
                }

                // Save updated list to Firebase Storage as JSON file
                const jsonData = JSON.stringify(existingProducts, null, 2);
                const blob = new Blob([jsonData], { type: 'application/json' });

                const storageRef = storage.ref(`productData/${category}-products.json`);

                // Upload the file with 30-day CDN cache for optimal performance
                const uploadTask = await storageRef.put(blob, {
                    contentType: 'application/json',
                    cacheControl: 'public, max-age=2592000' // 30 days CDN cache
                });

                console.log('Products JSON file updated successfully with', existingProducts.length, 'products');

                // Skip verification to avoid the "Failed to fetch" error
                console.log('Save completed successfully, skipping verification to avoid fetch errors');

                return true;
            } catch (error) {
                console.error('Error saving product data:', error);

                // Check for specific Firebase errors
                if (error.code === 'permission-denied') {
                    throw new Error('Permission denied. Please check your Firebase security rules.');
                } else if (error.code === 'failed-precondition') {
                    throw new Error('Firebase configuration error. Please check your Storage setup.');
                } else if (error.message === 'Operation timeout') {
                    throw new Error('Operation timed out. Please check your internet connection and try again.');
                } else {
                    throw new Error(`Failed to save product: ${error.message}`);
                }
            }
        }

        // Form submission handler
        productForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const submitButton = document.getElementById('submitBtn');
            const originalText = submitButton.innerHTML;

            try {
                // Show loading state
                submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
                submitButton.disabled = true;
                loading.style.display = 'block';
                hideMessages();

                // Get form data
                const formData = new FormData(productForm);
                const productData = {
                    name: formData.get('productName'),
                    price: formData.get('productPrice') ? parseFloat(formData.get('productPrice')) : null,
                    stock: formData.get('productStock') !== '' ? parseInt(formData.get('productStock')) : null,
                    description: formData.get('productDescription'),
                    category: formData.get('productCategory')
                };

                // Handle edit mode vs create mode
                if (isEditMode && editProductId && originalProductData) {
                    console.log('Updating existing product:', editProductId);
                    
                    // For edit mode, only validate fields that are actually being changed
                    // Build updated product data with only changed values
                    const updatedProductData = {
                        ...originalProductData, // Start with original data
                        id: editProductId,
                        updatedAt: new Date().toISOString()
                    };

                    // Only update fields that have values (allowing partial updates)
                    if (productData.name && productData.name.trim()) {
                        updatedProductData.name = productData.name.trim();
                    }
                    if (productData.price && productData.price > 0) {
                        updatedProductData.price = productData.price;
                    }
                    if (productData.stock !== null && productData.stock >= 0) {
                        updatedProductData.stock = productData.stock;
                    }
                    if (productData.description && productData.description.trim()) {
                        updatedProductData.description = productData.description.trim();
                    }
                    if (productData.category) {
                        updatedProductData.category = productData.category;
                    }

                    // Handle images - only update if there are selected images
                    if (selectedImages.length > 0) {
                        updatedProductData.images = await processSelectedImages();
                        updatedProductData.mainImage = updatedProductData.images.find(img => img.isMain)?.url || updatedProductData.images[0]?.url;
                    }

                    await updateProductData(updatedProductData, editCategory);
                    showSuccess('Product updated successfully!');
                } else {
                    console.log('Creating new product');
                    
                    // For new product creation, validate all required fields
                    if (!productData.name || !productData.price || !productData.category) {
                        throw new Error('Please fill in all required fields');
                    }

                    if (selectedImages.length === 0) {
                        throw new Error('Please select at least one product image');
                    }
                    
                    // Process images and create new product
                    productData.images = await processSelectedImages();
                    productData.mainImage = productData.images.find(img => img.isMain)?.url || productData.images[0]?.url;
                    productData.id = generateProductId(productData.category, productData.name, productData.price);
                    productData.createdAt = new Date().toISOString();
                    
                    await saveProductData(productData, productData.category);
                    showSuccess('Product created successfully!');
                }

                // Reset form after delay
                setTimeout(() => {
                    resetForm();
                }, 2000);

            } catch (error) {
                console.error('Error saving product:', error);
                showError(error.message);
            } finally {
                submitButton.innerHTML = originalText;
                submitButton.disabled = false;
                loading.style.display = 'none';
            }
        });
        // Helper functions
        function hideMessages() {
            successMessage.style.display = 'none';
            errorMessage.style.display = 'none';
        }

        function showSuccess(message) {
            successMessage.style.display = 'block';
            successMessage.textContent = message;
            hideError();
        }

        function showError(message) {
            errorMessage.style.display = 'block';
            errorText.textContent = message;
            hideSuccess();
        }

        function hideSuccess() {
            successMessage.style.display = 'none';
        }

        function hideError() {
            errorMessage.style.display = 'none';
        }

        function resetForm() {
            // Reset form fields
            productForm.reset();

            // Reset image selection
            selectedImages = [];
            mainImageIndex = 0;
            imageGrid.innerHTML = '';
            imageCache.clear();

            // Reset edit mode
            isEditMode = false;
            editProductId = null;
            editCategory = null;
            originalProductData = null;

            // Reset UI text
            document.querySelector('.admin-header h1').innerHTML = 'Nazakat Admin Panel';
            document.querySelector('.admin-header p').textContent = 'Product Management System';
            document.getElementById('submitBtn').innerHTML = '<i class="fas fa-plus"></i> Add Product';

            // Restore required attributes for new product creation
            document.getElementById('productName').setAttribute('required', '');
            document.getElementById('productPrice').setAttribute('required', '');
            document.getElementById('productStock').setAttribute('required', '');
            document.getElementById('productDescription').setAttribute('required', '');
            document.getElementById('productCategory').setAttribute('required', '');
            document.getElementById('multiImageInput').setAttribute('required', '');

            // Hide messages
            hideMessages();

            console.log('Form reset completed');
        }

        // Process selected images for both create and edit modes
        async function processSelectedImages() {
            const imageUrls = [];
            let newImageCount = 0;
            
            for (let i = 0; i < selectedImages.length; i++) {
                const file = selectedImages[i];
                let url;
                
                if (file.existingUrl || file.isExisting) {
                    // If it's an existing image during edit, use its URL directly
                    url = file.existingUrl || file.url;
                    console.log(`Using existing image URL: ${url}`);
                } else {
                    // Upload new image and get its URL
                    newImageCount++;
                    const timestamp = Date.now();
                    const randomId = Math.random().toString(36).substring(2, 8);
                    const productId = editProductId || generateProductId(editCategory || document.getElementById('productCategory').value || 'temp', document.getElementById('productName').value || 'product', 0);
                    const fileName = `${productId}_${timestamp}_${i}_${randomId}.jpg`;
                    
                    console.log(`Uploading new image ${newImageCount}: ${file.name || 'Unknown'}`);
                    url = await uploadSingleImage(file, fileName, newImageCount - 1, selectedImages.filter(img => !img.isExisting).length);
                }
                
                imageUrls.push({
                    url: url,
                    isMain: i === mainImageIndex,
                    alt: `${document.getElementById('productName').value} - Image ${i + 1}`
                });
            }
            
            console.log(`Processed ${imageUrls.length} total images (${newImageCount} new uploads, ${imageUrls.length - newImageCount} existing)`);
            return imageUrls;
        }

    </script>
</body>
</html>